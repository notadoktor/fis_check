from typing import Any, Generator, Iterable, Iterator, Optional, Self, Sequence

TagStr = Tag | NavigableString

class PageElement:
    default: Any = ...
    @property
    def name(self) -> str: ...
    @property
    def parents(self) -> Generator[PageElement, None, None]: ...
    @property
    def previous(self) -> TagStr: ...
    @property
    def next(self) -> TagStr: ...
    @property
    def stripped_strings(self) -> Generator[str | NavigableString, None, None]: ...
    def __contains__(self, key: str) -> bool: ...
    def __delitem__(self, key: str) -> None: ...
    def __getitem__(self, key: str) -> str: ...
    def __iter__(self) -> Iterable[Tag]: ...
    def __len__(self) -> int: ...
    def __setitem__(self, key: str, value: str) -> None: ...
    def append(self, tag: PageElement) -> Self: ...
    def extend(self, tags: Iterable[PageElement]) -> Self: ...
    def extract(self) -> Self: ...
    def find_all_next(
        self, name=None, attrs={}, string=None, limit=None, **kwargs
    ) -> ResultSet: ...
    def find_all_previous(
        self, name=None, attrs={}, string=None, limit=None, **kwargs
    ) -> ResultSet: ...
    def find_next(self, name=None, attrs={}, string=None, **kwargs) -> TagStr: ...
    def find_next_sibling(self, name=None, attrs={}, string=None, **kwargs) -> TagStr: ...
    def find_next_siblings(
        self, name=None, attrs={}, string=None, limit=None, **kwargs
    ) -> ResultSet: ...
    def find_parent(self, name=None, attrs={}, string=None, **kwargs) -> TagStr: ...
    def find_parents(self, name=None, attrs={}, string=None, limit=None, **kwargs) -> ResultSet: ...
    def find_previous(self, name=None, attrs={}, string=None, **kwargs) -> TagStr: ...
    def find_previous_sibling(self, name=None, attrs={}, string=None, **kwargs) -> TagStr: ...
    def find_previous_siblings(
        self, name=None, attrs={}, string=None, limit=None, **kwargs
    ) -> ResultSet: ...
    def format_string(self, formatter: str) -> str | bytes: ...
    def get_text(self, separator: str = "", strip: bool = False) -> str: ...
    def insert(self, position: int, new_child: PageElement) -> Self: ...
    def insert_after(self, *args: PageElement) -> Self: ...
    def insert_before(self, *args: PageElement) -> Self: ...
    def replace_with(self, *args: PageElement) -> Self: ...
    def setup(self, parent: Optional[Tag], previous: Optional[Tag]) -> None: ...
    def unwrap(self) -> Self: ...
    def wrap(self, wrap: PageElement) -> Self: ...
    @property
    def div(self) -> Tag: ...
    @property
    def span(self) -> Tag: ...
    @property
    def parent(self) -> Optional[Tag]: ...

class Tag(PageElement):
    @property
    def string(self) -> Optional[str | NavigableString]: ...
    @property
    def stripped_strings(self) -> list[str]: ...
    @property
    def descendants(self) -> Generator[PageElement, None, None]: ...
    @property
    def children(self) -> Iterator[TagStr]: ...
    def decompose(self) -> None: ...
    def clear(self, decompose: bool) -> None: ...
    def smooth(self) -> None: ...
    def index(self, element: PageElement) -> int: ...
    def get(self, key: str, default: Optional[str] = None) -> Optional[str]: ...
    def has_attr(self, key: str) -> bool: ...
    def encode(
        self,
        encoding: Optional[str] = None,
        indent_level: Optional[int] = None,
        formatter: str = "minimal",
        errors: str = "xmlcharrefreplace",
    ) -> bytes: ...
    def decode(
        self,
        indent_level: Optional[int],
        eventual_encoding: str,
        formatter: str,
    ) -> str | bytes: ...
    def prettify(self, encoding: Optional[str] = None, formatter: str = "minimal") -> str: ...
    def decode_contents(
        self,
        indent_level: Optional[int],
        eventual_encoding: str,
        formatter: str,
    ) -> str | bytes: ...
    def encode_contents(
        self,
        encoding: Optional[str],
        indent_level: Optional[int],
        formatter: str,
        errors: str,
    ) -> bytes: ...
    def renderContents(
        self, encoding: Optional[str] = None, formatter: str = "minimal"
    ) -> bytes: ...
    def find(
        self, name=None, attrs={}, recursive: bool = True, string=None, **kwargs
    ) -> Optional[TagStr]: ...
    def find_all(
        self, name=None, attrs={}, recursive: bool = True, string=None, **kwargs
    ) -> ResultSet: ...
    def select_one(
        self, selector: str, namespaces: Optional[dict[str, str]] = None, **kwargs: str
    ) -> Optional[Tag]: ...
    def select(
        self, selector: str, namespaces: Optional[dict[str, str]] = None, **kwargs: str
    ) -> ResultSet: ...
    def __getitem__(self, key: str) -> Any: ...
    def __setitem__(self, key: str, value: Any) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __contains__(self, key: str) -> bool: ...
    def __iter__(self) -> Iterable[TagStr]: ...

class NavigableString(str, PageElement):
    def strip(self) -> str: ...
    def output_ready(self, formatter: str = "minimal") -> str: ...
    @property
    def name(self) -> None: ...

class ResultSet(Sequence[PageElement]):
    source: object
